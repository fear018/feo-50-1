// Map – это коллекция ключ/значение, как и Object.
// Но основное отличие в том, что Map позволяет использовать ключи любого типа.

// Методы и свойства:
// new Map() – создаёт коллекцию.
// map.set(key, value) – записывает по ключу key значение value.
// map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
// map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
// map.delete(key) – удаляет элемент (пару «ключ/значение») по ключу key.
// map.clear() – очищает коллекцию от всех элементов.
// map.size – возвращает текущее количество элементов.

// Например:
// let map = new Map();

// map.set("1", "str1");    // строка в качестве ключа
// map.set(1, "num1");      // цифра как ключ
// map.set(true, "bool1");  // булево значение как ключ

// Объект Set – это особый вид коллекции: «множество» значений (без ключей),
// где каждое значение может появляться только один раз.

// Его основные методы это:
// new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
// set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
// set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
// set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
// set.clear() – удаляет все имеющиеся значения.
// set.size – возвращает количество элементов в множестве.

// let set = new Set();

// let john = { name: "John" };
// let pete = { name: "Pete" };
// let mary = { name: "Mary" };

// // считаем гостей, некоторые приходят несколько раз
// set.add(john);
// set.add(pete);
// set.add(mary);
// set.add(john);
// set.add(mary);

// Date
// getFullYear() Получить год (4 цифры)
// getMonth() Получить месяц, от 0 до 11.
// getDate() Получить день месяца, от 1 до 31, что несколько противоречит названию метода.
// getHours(), getMinutes(), getSeconds(), getMilliseconds()
// Получить, соответственно, часы, минуты, секунды или миллисекунды.
// getFullYear() Year
// getDay() Кроме того, можно получить определённый день недели
// Date.now(); возвращает текущую метку времени – количество миллисекунд, прошедших с 1 января 1970 года

// const options = {
//   weekday: "long",
//   year: "numeric",
//   month: "long",
//   day: "numeric",
// };

// console.log(date.toLocaleString("de-DE", options));
// "Donnerstag, 20. Dezember 2012"

// Recursion
// Итеративный способ: цикл for:
// function pow(x, n) {
//   let result = 1;

//   // умножаем result на x n раз в цикле
//   for (let i = 0; i < n; i++) {
//     result *= x;
//   }

//   return result;
// }

// alert( pow(2, 3) ); // 8

// Рекурсивный способ: упрощение задачи и вызов функцией самой себя:
// function pow(x, n) {
//   if (n == 1) {
//     return x;
//   } else {
//     return x * pow(x, n - 1);
//   }
// }

// alert( pow(2, 3) ); // 8

// Замыкание это механизм, где
// функция у которой есть доступ к своей внешней функции по области видимости,
// после того, как внешняя функция прекратилась.
// Это говорит о том, что замыкание может запоминать и получать доступ к переменным,
// и аргументам своей внешней функции, даже после того, как та прекратит выполнение.

// пример замыкания
// function setName(name) {

//   return function () {
//     return `${name} есть доступ к внешней переменной`;
//   };
// }

// Сборщик мусора
// Большая часть алгоритмов сборки мусора основана на понятии ссылки.
// В контексте управления памятью объект считается ссылающимся на другой объект,
// если у первого есть доступ ко второму (неважно - явный или неявный).

// Сборка мусора на основе подсчёта ссылок.
// Основное ограничение данного наивного алгоритма заключается в том,
// что если два объекта ссылаются друг на друга (создавая таким образом циклическую ссылку),
// они не могут быть уничтожены сборщиком мусора, даже если "более не нужны".

// Любое другое значение считается достижимым,
// если оно доступно из корня по ссылке или по цепочке ссылок.

// Существует 2 основных отличия var от let/const:

// Переменные var не имеют блочной области видимости,
// они ограничены, как минимум, телом функции.
// Объявления (инициализация) переменных var производится
// в начале исполнения функции (или скрипта для глобальных переменных).

// eval
// let code = 'alert("Привет")';
// eval(code);

// Каррирование – это трансформация функций таким образом,
// чтобы они принимали аргументы не как f(a, b, c), а как f(a)(b)(c).

// Каррирование не вызывает функцию. Оно просто трансформирует её.

// function curry(f) { // curry(f) выполняет каррирование
//   return function(a) {
//     return function(b) {
//       return f(a, b);
//     };
//   };
// }

// // использование
// function sum(a, b) {
//   return a + b;
// }

// let curriedSum = curry(sum);

// alert( curriedSum(1)(2) ); // 3

// Флаги и дескрипторы свойств
// let user = {
//   name: "John"
// };

// let descriptor = Object.getOwnPropertyDescriptor(user, 'name');
/* дескриптор свойства:
{
  "value": "John",
  "writable": true, - если false, то нельзя менять значение свойства
  "enumerable": true, - если false, то свойство не появится в цикле for..in и в Object.keys
  "configurable": true - если false, то нельзя удалить свойство и менять его флаги
}
*/

// let user = {
//   name: "John"
// };

// Object.defineProperty(user, "name", {
//   writable: false
// });

// user.name = "Pete";

// Свойства - геттеры и сеттеры
// Это свойства-аксессоры (accessor properties).
// Свойства-аксессоры представлены методами: «геттер» – для чтения и «сеттер» – для записи.
// При литеральном объявлении объекта они обозначаются get и set:

// let obj = {
//   get propName() {
//     // геттер, срабатывает при чтении obj.propName
//   },

//   set propName(value) {
//     // сеттер, срабатывает при записи obj.propName = value
//   }
// };

// let user = {
//   name: "John",
//   surname: "Smith",

//   get fullName() {
//     return `${this.name} ${this.surname}`;
//   },

//   set fullName(value) {
//     [this.name, this.surname] = value.split(" ");
//   }
// };

// // set fullName запустится с данным значением
// user.fullName = "Alice Cooper";

// alert(user.name); // Alice
// alert(user.surname); // Cooper
