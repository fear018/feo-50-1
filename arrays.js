// Массив – это особый тип объекта, предназначенный для работы с упорядоченным набором элементов.

// // квадратные скобки (обычно)
// let arr = [item1, item2...];

// // new Array (очень редко)
// let arr = new Array(item1, item2...);

// Мы можем получить элемент по его индексу, например arr[0].

// Чтобы пройтись по элементам массива:
// for (let i=0; i<arr.length; i++) – работает быстрее всего, совместим со старыми браузерами.
// for (let item of arr) – современный синтаксис только для значений элементов (к индексам нет доступа).

// Методы массивов
// Полный список есть в справочнике MDN.
// push(...items)добавляет items в конец массива.
// pop() удаляет элемент в конце массива и возвращает его.
// shift() удаляет элемент в начале массива и возвращает его.
// unshift(...items) добавляет items в начало массива.

// let arr = ["I", "go", "home"];
// delete arr[1]; // удалить "go"
// alert(arr[1]); // undefined
// // теперь arr = ["I",  , "home"];
// alert(arr.length); // 3

// Для добавления/удаления элементов:
// splice(pos, deleteCount, ...items) – начиная с индекса pos удаляет deleteCount элементов и вставляет items.
// let arr = ["Я", "изучаю", "JavaScript"];
// arr.splice(1, 1); // начиная с индекса 1, удалить 1 элемент

// удалить 3 первых элемента и заменить их другими

// slice(start, end) – создаёт новый массив, копируя в него элементы с индекса start до end (не включая end).
// let arr = ["t", "e", "s", "t"];
// alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)

// concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.
// let arr = [1, 2];
// // создать массив из: arr и [3,4]
// alert( arr.concat([3, 4]) ); // 1,2,3,4
// // создать массив из: arr и [3,4] и [5,6]
// alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6
// // создать массив из: arr и [3,4], потом добавить значения 5 и 6
// alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6

// Для поиска среди элементов:
// indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
// let arr = [1, 0, false];
// alert( arr.indexOf(0) ); // 1

// let fruits = ['Яблоко', 'Апельсин', 'Яблоко']
// alert( fruits.indexOf('Яблоко') ); // 0 (первый 'Яблоко')
// alert( fruits.lastIndexOf('Яблоко') ); // 2 (последний 'Яблоко')

// includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
// fruits.includes('Яблоко'); // true

// find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
// let result = arr.find(function(item, index, array) {
//   // если true - возвращается текущий элемент и перебор прерывается
//   // если все итерации оказались ложными, возвращается undefined
// });
// let users = [
//   {id: 1, name: "Вася"},
//   {id: 2, name: "Петя"},
//   {id: 3, name: "Маша"}
// ];

// let user = users.find(item => item.id == 1);

// alert(user.name);

// let users = [
//   {id: 1, name: "Вася"},
//   {id: 2, name: "Петя"},
//   {id: 3, name: "Маша"}
// ];

// // возвращает массив, состоящий из двух первых пользователей
// let someUsers = users.filter(item => item.id < 3);

// alert(someUsers.length); // 2
// findIndex похож на find, но возвращает индекс вместо значения.

// Для перебора элементов:
// forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.
// arr.forEach(function(item, index, array) {
//   // ... делать что-то с item
// });
// ["Бильбо", "Гэндальф", "Назгул"].forEach(alert);

// Для преобразования массива:
// map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
// let lengths = ["Бильбо", "Гэндальф", "Назгул"].map(item => item.length);
// alert(lengths); // 6,8,6

// sort(func) – сортирует массив «на месте», а потом возвращает его.
// let arr = [ 1, 2, 15 ];

// // метод сортирует содержимое arr
// arr.sort();
// лексикографический порядок
// alert( arr );  // 1, 15, 2
// var myarray=[25, 8, 7, 41]
// myarray.sort(function(a,b){
//   return a — b
// }) //Массив будет [7, 8, 25, 41]

// var myarray=[25, 8, 7, 41]
// myarray.sort(function(a,b){
//   return b — a
// }) //Массив становится [41, 25, 8, 7]

// reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
// let arr = [1, 2, 3, 4, 5];
// arr.reverse();

// alert( arr ); // 5,4,3,2,1

// split/join – преобразует строку в массив и обратно.
// let names = 'Вася, Петя, Маша';
// let arr = names.split(', ');
// join

// reduce/reduceRight(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.
// let value = arr.reduce(function(accumulator, item, index, array) {
//   // ...
// }, [initial]);

// accumulator – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial),
// item – очередной элемент массива,
// index – его позиция,
// array – сам массив.

// let arr = [1, 2, 3, 4, 5];

// let result = arr.reduce((sum, current) => sum + current, 0);

// alert(result); // 15

// Дополнительно:
// Array.isArray(arr) проверяет, является ли arr массивом.

// Метод some() проверяет, удовлетворяет ли какой-либо элемент массива условию, заданному в передаваемой функции.
// const array = [1, 2, 3, 4, 5];

// // Checks whether an element is even
// const even = (element) => element % 2 === 0;

// console.log(array.some(even));
// // Expected output: true

// Метод every() проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.
